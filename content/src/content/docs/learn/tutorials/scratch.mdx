---
type: Tutorial
title: Scratch
tags:
  - some
  - tags
sidebar:
  order: 999
---

## Adding error handling to our database query

All this talk of error handling might have gotten you thinking: can't our
database query fail? It can! If the query is malformed, `db.query` will throw an
error. When that happens, our endpoint will currently return a 500 error to
the client. Change the SQL query to `SELECT * FROM nonexistent` and try it:

```shell
http get "localhost:3000/users"
```

```http
HTTP/1.1 500 Internal Server Error
Content-Length: 0
Date: Fri, 14 Feb 2025 17:25:57 GMT
X-Powered-By: Express
```

Strictly speaking, a 500 error is correct here. Our server encountered an error
because of a server-side problem, which is what the 500-class errors are for.
But it's not good Effect to let exceptions sneak by like this.

A simple thing we can do is changing `Effect.promise` to `Effect.tryPromise`:

```ts twoslash
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg"
const db = new Client({ user: "postgres" })
//---cut---
const users = Effect.tryPromise(
  () => db.query("SELECT * FROM users")
).pipe(
  Effect.map(({ rows }) => ({ users: rows })),
  Effect.flatMap(HttpServerResponse.json)
)
```

This changes the return type from:

```typescript
Effect<HttpServerResponse, HttpBodyError, never>
```

To:

```typescript
Effect<HttpServerResponse, UnknownException | HttpBodyError, never>
```

`Effect.promise` is assumed to always succeed. `Effect.tryPromise` is assumed
to maybe throw an exception, but because TypeScript doesn't give us any way
to know _what_ exception might be thrown, Effect defaults to `UnknownException`.

We can improve on this:

```ts twoslash {1,4-5}
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client} from "pg"
const db = new Client({ user: "postgres" })
//---cut---
class UserFetchError extends Error {}

const users = Effect.tryPromise({
  try: () => db.query("SELECT * FROM users"),
  catch: (cause) => new UserFetchError("failed to fetch users", { cause }),
}).pipe(
  Effect.map(({ rows }) => ({ users: rows })),
  Effect.flatMap(HttpServerResponse.json)
)
```

We're using a different variant of `Effect.tryPromise` to give us more control
over the type of the error that is returned. Becuase it's difficult to know what
errors may be thrown by third-party libraries, it's idiomatic to create new
error types that wrap the original error.

Now our effect has the type:

```typescript
Effect<HttpServerResponse, UserFetchError | HttpBodyError, never>
```

Now our program is aware of what can go wrong _at the type level_. This
information is completely missing if you're using exceptions in TypeScript.
With this information we can ensure, and get TypeScript to verify for us,
that things do not go wrong in unexpected ways.

```ts twoslash
// @errors: 2375
import { Effect } from "effect"

const effect = Effect.succeed(1).pipe(
  Effect.tryMap({
    try: (n) => n + 1,
    catch: () => new Error(),
  }),
)

const noError: Effect.Effect<number, never, never> = effect
```

The above code fails because we try to assign an Effect that can fail to a
variable that expects an Effect that can't fail. We can fix this error in a
few ways.

By providing a default value:

```ts twoslash {8}
import { Effect } from "effect"

const effect = Effect.succeed(1).pipe(
  Effect.tryMap({
    try: (n) => n + 1,
    catch: () => new Error(),
  }),
  Effect.orElseSucceed(() => 0),
)

const noError: Effect.Effect<number, Error, never> = effect
```

Or by converting the error into what Effect calls a "defect":

```ts twoslash {8}
import { Effect } from "effect"

const effect = Effect.succeed(1).pipe(
  Effect.tryMap({
    try: (n) => n + 1,
    catch: () => new Error(),
  }),
  Effect.orDie
)

const noError: Effect.Effect<number, Error, never> = effect
```

This effectively recreates the behaviour of throwing an exception. Defects are
critical errors that you don't want to handle. If you were to create a defect in
an Effect handler, the result would be a 500 error returned to the user.
