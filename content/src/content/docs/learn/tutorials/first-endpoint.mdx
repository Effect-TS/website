---
type: Tutorial
title: Our first Effect endpoint
tags:
  - some
  - tags
sidebar:
  order: 2
---

import { Aside } from "@astrojs/starlight/components"

The first step to writing Effect is to modify our Express app to allow it to
serve both Effect and Express endpoints at the same time. We need to first add
some dependencies to our project:

```shell showLineNumbers=false
bun add effect @effect/platform @effect/platform-node
```

<Aside type="note" title="Why @effect/platform-node?">
The `@effect/platform-node` there isn't a mistake. Provided your runtime
supports `node:http`, you can use `@effect/platform-node` to run your Effect
app.

Effect does have an `@effect/platform-bun`, which uses Bun's own HTTP server,
but to make sure this tutorial is as widely applicable as possible, I'm going
to use `@effect/platform-node`.
</Aside>

The first step is to introduce some boilerplate code that will allow us to
serve both Effect and Express endpoints at the same time. I'm not expecting you
to understand everything you read in the following code block, all will be
explained as we progress through this tutorial.

```ts twoslash ins={3-5,16-26} del={13-15} title=index.ts showLineNumbers=false
import express from "express"

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { HttpRouter } from "@effect/platform"
import { Effect } from "effect"

const app = express()

app.get("/health", (req, res) => {
  res.type("text/plain").send("ok")
})

app.listen(3000, () => {
  console.log("Server is running on http://localhost:3000")
})
const router = HttpRouter.empty

const main = Effect.gen(function* () {
  app.use(yield* NodeHttpServer.makeHandler(router))
  app.listen(3000, () => {
    console.log("Server is running on http://localhost:3000")
  })
  yield* Effect.never
})

NodeRuntime.runMain(main)
```

Our Express `/health` handler still works as expected, but we've wrapped the
Express app in a way that will allow us to define endpoints using Effect
while still responding to our existing endpoints in Express.

There's a lot of new things happening at the bottom of our file. What is
`Effect.gen`, what are those `yield*`s doing, what is `Effect.never`. For the
time being we're going to set these questions aside. It looks intimidating now,
but if you stick with this tutorial to the end, it will not only make sense, but
start to become second nature.

## Our new `/health` handler

The Effect equivalent of our Express `/health` handler looks like this:

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
// ---cut---
import { HttpServerResponse } from "@effect/platform"

const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
```

`HttpServerResponse` is Effect's class for generating HTTP responses, we need to
use it for any responses returned from Effect.

The way we wire this into our Effect `router` is going to look a little bit
strange, but please stay with me:

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
// ---cut---
import { HttpServerResponse, HttpRouter } from "@effect/platform"

const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", health),
)
```

What on earth are `Effect.sync` and `.pipe`?

## The Effect Type

At the core of Effect is... well, the `Effect`. You can think of an `Effect` as
a lazy computation, similar to a function that hasn't been called yet.

Here's an example of an `Effect` that returns the string `"Hello, world!"`:

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
// ---cut---
Effect.sync(() => "Hello, world!")
```

<Aside type="note">
Returning a static value like this isn't something you would do in practice.
The examples below are simplified to demonstrate how to use the `Effect` type.
</Aside>

`Effect.sync` takes a function and creates an `Effect` out of it. If you need to
do asynchronous work in an Effect, you can use `Effect.promise`:

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
// ---cut---
Effect.promise(async () => "Hello, world!")
```

If we want to run these Effects, we can use `Effect.runPromise`:

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
// ---cut---
const syncResult = Effect.runPromise(
  Effect.sync(() => "Hello, world!")
)
console.log(syncResult)
// => "Hello, world!"

const asyncResult = await Effect.runPromise(
  Effect.promise(async () => "Hello, world!")
)
console.log(asyncResult)
// => "Hello, world!"
```

`Effect.runPromise` runs an Effect and returns a `Promise` that resolves to the
result of the Effect. You can pass both synchronous and asynchronous Effects to
`Effect.runPromise`, and it will handle them both.

What if you want to run an Effect that uses the result of another Effect? You
can use `Effect.gen` to do that:

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
// ---cut---
const effect = Effect.sync(() => "Hello, world!")
const gen = Effect.gen(function* () {
  const str = yield* effect
  return str.toUpperCase()
})
const result = await Effect.runPromise(gen)
console.log(result)
// => "HELLO, WORLD!"
```

This makes use of JavaScript's [generator functions][1].  You can think of an
Effect as being like a `Promise`, and `yield*`ing an `Effect` is the same as
`await`ing a `Promise`.  Under the hood, all `Effect`s are generators, and
`yield*`ing one passes it to the Effect runtime and waits for the result.

`Effect.gen` is one of the most versatile ways to create Effects, and you'll use
it a lot. Another thing you'll see used a lot is `Effect.pipe`. Here's an
example that does the same work as code as above, but using `Effect.pipe`:

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
// ---cut---
const effect = Effect.sync(() => "Hello, world!").pipe(
  Effect.map((s) => s.toUpperCase())
)
const result = await Effect.runPromise(effect)
console.log(result)
// => "HELLO, WORLD!"
```

`pipe` passes the result of one Effect as input to another. Here,
`Effect.map` transforms the result of the first `Effect` with the function
provided.

We can `pipe` as many `Effect`s together as we like:

```ts twoslash ins={3-5} showLineNumbers=false
import { Effect } from "effect"
// ---cut---
const effect = Effect.sync(() => "Hello, world!").pipe(
  Effect.map((s) => s.toUpperCase()),
  Effect.map((s) => s.split("")),
  Effect.map((s) => s.reverse()),
  Effect.map((s) => s.join("")),
)
const result = await Effect.runPromise(effect)
console.log(result)
// => "!DLROW ,OLLEH"
```

This should give us just enough to carry on with migrating our first endpoint
to Effect. As we continue through this tutorial, we'll introduce more and more
things you can do with the `Effect` type.

## Understanding `HttpRouter`

Looking back at our `HttpRouter`, we used `pipe` to add a new endpoint to our
app:

```ts twoslash showLineNumbers=false
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"
const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
// ---cut---
const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", health),
)
```

`HttpRouter` is a data structure that represents a collection of routes. The
simplest router is one with no routes at all, and Effect exposes that to us as
the `HttpRouter.empty` value. Under the hood, this is itself an `Effect`:

```ts twoslash showLineNumbers=false
import { HttpRouter } from "@effect/platform"
import { Effect } from "effect"
// ---cut---
console.log(Effect.isEffect(HttpRouter.empty))
// => true
```

The helper `HttpRouter.get` takes an `HttpRouter` as an argument and returns a
new `HttpRouter` with the given route added. If we wanted to, we could have
called it like a regular function. The following two lines of code do exactly
the same thing:

```ts twoslash showLineNumbers=false
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"
const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
// ---cut---
HttpRouter.empty.pipe(HttpRouter.get("/health", health))
HttpRouter.get("/health", health)(HttpRouter.empty)
```

If we add a few more routes, though, we can see how this gets quickly out of
hand:

```ts twoslash showLineNumbers=false
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"
const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
const status = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
const version = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
// ---cut---
HttpRouter.get("/health", health)(
  HttpRouter.get("/status", status)(
    HttpRouter.get("/version", version)(
      HttpRouter.empty,
    ),
  ),
)

// vs

HttpRouter.empty.pipe(
  HttpRouter.get("/version", version),
  HttpRouter.get("/status", status),
  HttpRouter.get("/health", health),
)
```

## The end result

Here's the full code of our app with our `/health` endpoint being served by
Effect:

```ts twoslash {9-15} showLineNumbers=false
import express from "express"

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"

const app = express()

const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", health)
)

const main = Effect.gen(function* () {
  app.use(yield* NodeHttpServer.makeHandler(router))
  app.listen(3000, () => {
    console.log("Server is running on http://localhost:3000")
  })
  yield* Effect.never
})

NodeRuntime.runMain(main)
```

And the output of the endpoint:

```shell showLineNumbers=false
http -pb get localhost:3000/health
```

```http showLineNumbers=false
ok
```

[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*
