---
type: Tutorial
title: Calling an API
tags:
  - some
  - tags
sidebar:
  order: 4
---

Next up we're going to take a look at an endpoint that makes an API call to
another service. Here's the code:

```ts twoslash title=index.ts ins={9-19} showLineNumbers=false
import express from "express"

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { HttpRouter } from "@effect/platform"
import { Effect } from "effect"

const app = express()

app.get("/wow", async (req, res) => {
  const url = new URL(`https://owen-wilson-wow-api.onrender.com/wows/random`)

  const year = req.query.year
  if (typeof year === "string") {
    url.searchParams.set("year", year)
  }

  const wow = await fetch(url.toString())
  res.json(await wow.json())
})

const router = HttpRouter.empty

const main = Effect.gen(function* () {
  app.use(yield* NodeHttpServer.makeHandler(router))
  app.listen(3000, () => {
    console.log("Server is running on http://localhost:3000")
  })
  yield* Effect.never
})

NodeRuntime.runMain(main)
```

I've removed our `/health` and `/users` endpoints to keep the code to a
reasonable length.

For a bit of fun I've chosen the [Owen Wilson Wow
API](https://owen-wilson-wow-api.onrender.com/) as our API to call. I've also
decided to use a query parameter to filter the results by year, to show how this
works in Effect.

## Referencing the current request

If we were to reach straight away for `Effect.promise`, we would quickly
run into a problem: how do we reference the HTTP request object? We need to
get the `year` from the query parameters, but if you look back at our 
`/users` endpoint, you'll see that there's no request object.

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
import { HttpServerResponse } from "@effect/platform"
import { Client } from "pg"
const db = new Client({ user: "postgres" })
//---cut---
const users = Effect.promise(
  () => db.query("SELECT * FROM users"),
).pipe(
  Effect.map(({ rows }) => ({ users: rows })),
  Effect.flatMap(HttpServerResponse.json),
)
```

The way that Effect exposes the request object is through the
`HttpServerRequest` Effect. Near the start of this tutorial we used `Effect.gen`
to get the result of one Effect while inside another, and we can do the same
here.

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
//---cut---
import { HttpServerRequest, HttpServerResponse } from "@effect/platform"

const query = Effect.gen(function* () {
  const req = yield* HttpServerRequest.HttpServerRequest
  return yield* HttpServerResponse.json({ url: req.url })
})
```

If we wire this handler up as a new `/query` endpoint in our application:

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
import { HttpRouter, HttpServerRequest, HttpServerResponse } from "@effect/platform"
const query = Effect.gen(function* () {
  const req = yield* HttpServerRequest.HttpServerRequest
  return yield* HttpServerResponse.json({ url: req.url })
})
//---cut---
const router = HttpRouter.empty.pipe(
  HttpRouter.get("/query", query),
)
```

We can call it like so:

```shell showLineNumbers=false
http get "localhost:3000/query?year=2010"
```

```http showLineNumbers=false
HTTP/1.1 200 OK
Content-Length: 16
Content-Type: application/json
Date: Fri, 21 Feb 2025 16:41:03 GMT
X-Powered-By: Express

{
    "url": "/query?year=2010"
}
```

## Effect requirements

Let's look a bit closer at our `query` Effect:

```ts twoslash showLineNumbers=false
import {
  HttpRouter,
  HttpServerRequest,
  HttpServerResponse,
} from "@effect/platform"
import { Effect } from "effect"
//---cut---
const query = Effect.gen(function* () {
  //  ^?
  const req = yield* HttpServerRequest.HttpServerRequest
  return yield* HttpServerResponse.json({ url: req.url })
})
```

An Effect that returns an `HttpServerResponse`, may throw an `HttpBodyError`,
but also, for the first time, has something other than `never` in that third
spot. As a reminder, this is the `Requirement` type. What it's saying here is
that, to execute, this Effect requires an `HttpServerRequest`.

If we were to try and run this Effect directly, we would get a type error:

```ts twoslash showLineNumbers=false
// @errors: 2379
import {
  HttpRouter,
  HttpServerRequest,
  HttpServerResponse,
} from "@effect/platform"
import { Effect } from "effect"
const query = Effect.gen(function* () {
  const req = yield* HttpServerRequest.HttpServerRequest
  return yield* HttpServerResponse.json({ url: req.url })
})
//---cut---
Effect.runPromise(query)
```

What this is telling us is that this Effect cannot be run unless an
`HttpServerRequest` is provided to it.

## Providing requirements

The way we provide an Effect with things it needs is through the use of
"services." If you've used dependency injection in other languages, Effect's
services are the same idea.

To keep track of what services are available, Effect maintains an internal
context object. You can think of this as a map of services, with the key being a
unique identifier for the service, and the value being the service itself.

Effect uses a special type called a `Tag` as the unique identifier for services,
and the syntax for defining one is unusual so bear with me here:

```ts twoslash showLineNumbers=false
import { Context, Effect } from "effect"
//---cut---
class FavouriteNumber extends Context.Tag("FavouriteNumber")<
  FavouriteNumber,
  number
>() {}

const effect = Effect.gen(function* () {
  const n = yield* FavouriteNumber
  console.log(`My favourite number is ${n}`)
})
```

The class declaration at the top defines the tag as well as the type for the
service. In this example we just return a `number`, but if you wanted to you
could return a more complex object.

In the `Effect.gen` call we `yield*` the tag to get the value of the service.
Note that we haven't created an implementation of the service yet, so we won't
be able to run this Effect.

Here's how we would implement and then provide the service:

```ts twoslash showLineNumbers=false
import { Context, Effect } from "effect"
class FavouriteNumber extends Context.Tag("FavouriteNumber")<
  FavouriteNumber,
  number
>() {}

const effect = Effect.gen(function* () {
  const n = yield* FavouriteNumber
  console.log(`My favourite number is ${n}`)
})
//---cut---
Effect.runPromise(
  effect.pipe(Effect.provideService(FavouriteNumber, 42))
)
// => My favourite number is 42

Effect.runPromise(
  effect.pipe(Effect.provideService(FavouriteNumber, 100))
)
// => My favourite number is 100
```

Providing a service to an Effect ends up changing its type, too.

```ts twoslash showLineNumbers=false
import { Context, Effect } from "effect"
class FavouriteNumber extends Context.Tag("FavouriteNumber")<
  FavouriteNumber,
  number
>() {}
//---cut---
const needsRequirements = Effect.gen(function* () {
//    ^?
  const n = yield* FavouriteNumber
  console.log(`My favourite number is ${n}`)
})

const hasRequirements = needsRequirements.pipe(
//    ^?
  Effect.provideService(FavouriteNumber, 42)
)
```

We go from:

``` showLineNumbers=false
Effect<void, never, FavouriteNumber>
```

To:

``` showLineNumbers=false
Effect<void, never, never>
```

So each Effect can be thought of as a self-contained program. Services are its
inputs, it has an output, and it can error. Effect forces us to be more
deliberate about what our programs need to run, and that makes it easier to
reason about them.

So how is `HttpServerRequest` provided to our `query` Effect? It's the
`NodeHttpServer.makeHandler` function that does this. It takes our `HttpRouter`
Effect and provides a service to it that we can get the current request from.

## Parsing the query string

Now we know about services, and how the request object gets to us, let's do
something useful with it!

Here's where we left our `/query` endpoint:

```ts twoslash showLineNumbers=false
import {
  HttpRouter,
  HttpServerRequest,
  HttpServerResponse,
} from "@effect/platform"
import { Effect } from "effect"
//---cut---
const query = Effect.gen(function* () {
  const req = yield* HttpServerRequest.HttpServerRequest
  return yield* HttpServerResponse.json({ url: req.url })
})
```

We want to take that `req.url` and parse out the `year` query parameter. We can
do this with the `URL` class.

```ts twoslash ins={3-4} showLineNumbers=false
import {
  HttpRouter,
  HttpServerRequest,
  HttpServerResponse,
} from "@effect/platform"
import { Effect } from "effect"
//---cut---
const query = Effect.gen(function* () {
  const req = yield* HttpServerRequest.HttpServerRequest
  const url = new URL(req.url, `http://${req.headers.host}`)
  const year = url.searchParams.get("year")
  return yield* HttpServerResponse.json({ year })
})
```

And now we can see the year in the response:

```shell showLineNumbers=false
http get "localhost:3000/query?year=2010"
```

```http showLineNumbers=false
HTTP/1.1 200 OK
Content-Length: 15
Content-Type: application/json
Date: Fri, 07 Mar 2025 14:21:50 GMT
X-Powered-By: Express

{
    "year": "2010"
}
```

## Calling the API

Now that we have the `year` query parameter, we can use it to filter the results
from the API.

```ts twoslash ins={6-18} showLineNumbers=false
import {
  HttpRouter,
  HttpServerRequest,
  HttpServerResponse,
} from "@effect/platform"
import { Effect } from "effect"
//---cut---
const query = Effect.gen(function* () {
  const req = yield* HttpServerRequest.HttpServerRequest
  const requestUrl = new URL(req.url, `http://${req.headers.host}`)
  const year = requestUrl.searchParams.get("year")

  const apiUrl = new URL(
    "https://owen-wilson-wow-api.onrender.com/wows/random"
  )
  if (year !== null) {
    apiUrl.searchParams.set("year", year)
  }

  const response = yield* Effect.promise(async () => {
    const resp = await fetch(apiUrl.toString())
    return await resp.json()
  })

  return yield* HttpServerResponse.json(response)
})
```

And querying this endpoint we now get the filtered results:

```shell showLineNumbers=false
http get "localhost:3000/query?year=2010"
```

```http showLineNumbers=false
HTTP/1.1 200 OK
Content-Length: 1066
Content-Type: application/json
Date: Fri, 07 Mar 2025 14:45:01 GMT
X-Powered-By: Express

[
    {
        "audio": "https://assets.ctfassets.net/bs8ntwkklfua/3B0YwIinFRjyDhg87ubLnm/e7ca0400c19fe1fe118ebc2901dc3518/Little_Fockers_Wow_1.mp3",
        "character": "Kevin Rawley",
        "current_wow_in_movie": 1,
        "director": "Paul Weitz",
        "full_line": "Wow.",
        "movie": "Little Fockers",
        "movie_duration": "01:37:40",
        "poster": "https://images.ctfassets.net/bs8ntwkklfua/2uitJuVd7wiuh57N42VotB/97be419cc8d17405b256bf6f63afd461/Little_Fockers_Poster.jpg",
        "release_date": "2010-12-22",
        "timestamp": "00:26:32",
        "total_wows_in_movie": 2,
        "video": {
            "1080p": "https://videos.ctfassets.net/bs8ntwkklfua/6sQcwSbOHUtQwSa2AiGVx4/4bd91b3f82378c6cec36003010b6bc7b/Little_Fockers_Wow_1_1080p.mp4",
            "360p": "https://videos.ctfassets.net/bs8ntwkklfua/4NRdmxRxOFF7u8uSDCDpbz/f948d2f764468c89f5e37fa2b3804661/Little_Fockers_Wow_1_360p.mp4",
            "480p": "https://videos.ctfassets.net/bs8ntwkklfua/5jBrCwue7YyNWATPMsnEM3/3897126fa0cacee7817cb798db85a829/Little_Fockers_Wow_1_480p.mp4",
            "720p": "https://videos.ctfassets.net/bs8ntwkklfua/1MgGCFiDEMuDtZf5pPXZrq/9abb8fedcf84c2aad104a993cab043ef/Little_Fockers_Wow_1_720p.mp4"
        },
        "year": 2010
    }
]
```