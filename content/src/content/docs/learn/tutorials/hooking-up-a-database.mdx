---
type: Tutorial
title: Hooking up a database
tags:
  - some
  - tags
sidebar:
  order: 3
---

import { Aside } from "@astrojs/starlight/components"

The next endpoint we're going to write is one that lists all of the users in a
database. For this tutorial I'm going to use Postgres running in Docker as our
database. If you don't have Docker installed, I recommend following the
[official getting started guide](https://www.docker.com/get-started/).

When you're ready, you can start a Postgres container with:

```shell showLineNumbers=false
docker run -d -e POSTGRES_HOST_AUTH_METHOD=trust -p 5432:5432 postgres:17
```

<Aside type="note" title="I can't use Docker!">
If you aren't able to run Docker locally, for example because your work's laptop
policy doesn't allow it, an alternative is to use a hosted Postgres service.
</Aside>

## Creating test data

To create our `users` table and data, we're going to use the `psql`
tool that's present inside of the Docker container we created. Open a new
terminal and run:

```shell showLineNumbers=false
docker exec -it $(docker ps -qf ancestor=postgres:17) psql -U postgres
```

This will drop you into a `psql` shell, with a prompt that starts `postgres=#`.
From here you can run the following SQL commands:

```sql showLineNumbers=false
CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT);
INSERT INTO users (name) VALUES ('Alice');
INSERT INTO users (name) VALUES ('Bob');
```

To exit `psql`, type `\q` and press enter.

## The `/users` endpoint

To talk to Postgres we'll need a client library. We're going to use `pg` for
this tutorial. You can install it with:

```shell showLineNumbers=false
bun add pg 
bun add -D @types/pg
```

To start with, we're going to hardcode our database connection details. Later
on we'll learn how to use Effect to manage our app's configuration.

Here's the code for our app in full, with a new `/users` endpoint added in
Express:

```ts twoslash ins={6,8,11-14,25} title=index.ts showLineNumbers=false
import express from "express"

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"
import { Client } from "pg"

const db = new Client({ user: "postgres" })
const app = express()

app.get("/users", async (req, res) => {
  const { rows } = await db.query("SELECT * FROM users")
  res.send({ users: rows })
})

const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", health)
)

const main = Effect.gen(function* () {
  yield* Effect.promise(() => db.connect())
  app.use(yield* NodeHttpServer.makeHandler(router))
  app.listen(3000, () => {
    console.log("Server is running on http://localhost:3000")
  })
  yield* Effect.never
})

NodeRuntime.runMain(main)
```

Here's what you should see when you run this code and you've set up your
Postgres database correctly:

```shell showLineNumbers=false
http -pb get localhost:3000/users
```

```json showLineNumbers=false
{
    "users": [
        {
            "id": 1,
            "name": "Alice"
        },
        {
            "id": 2,
            "name": "Bob"
        }
    ]
}
```

## The direct approach

If we were to copy what we did with the `/health` endpoint, we'd end up with
broken code. Here's how it would look:

```ts twoslash showLineNumbers=false
import { HttpRouter, HttpServer, HttpServerResponse } from "@effect/platform"
import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg"
const db = new Client({ user: "postgres" })
const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})
//---cut---
// @errors: 2379
const users = Effect.promise(async () => {
  const { rows } = await db.query("SELECT * FROM users")
  return HttpServerResponse.json({ users: rows })
})

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", health),
  HttpRouter.get("/users", users),
)
```

Effect error messages can be difficult to decipher at first. What this one is
trying to tell us is that our `users` HTTP handler does not return the expected
type. The reason for this is that `HttpServerResponse.json` is an operation that
might fail. Not all JavaScript objects can be converted to JSON.

```ts twoslash showLineNumbers=false
JSON.stringify({ big: 10n })
//=> TypeError: JSON.stringify cannot serialize BigInt.
```

Because it can fail, instead of returning an `HttpServerResponse` directly,
it returns another `Effect`.

## Error handling in Effect

When we introduced the `Effect` type in the previous section, we dealt
exclusively with Effects that couldn't fail. That won't get us very far if
we're building anything non-trivial.

`Effect` is a generic type that takes 3 type arguments:

```typescript showLineNumbers=false
Effect<Success, Error, Requirements>
```

`Success` is the type the Effect returns when it succeeds, `Error` is the type
it returns when it fails, and we'll talk about `Requirements` in the next
section.

When we created our example Effects in the previous section, these all took on
the type `Effect<string, never, never>`.

```ts twoslash showLineNumbers=false
import { Effect } from "effect"
//---cut---
const s = Effect.sync(() => "Hello, world!")
// s: Effect<string, never, never>
```

This means they will return a `string` on success, and never fail.

When an `Effect` _can_ fail, its return value with have a different type. For
example, the `HttpServerResponse.json` function returns a value of type:

```typescript showLineNumbers=false
Effect<HttpServerResponse, HttpBodyError, never>
```

This means that it will return an `HttpServerResponse` on success, and an
`HttpBodyError` on failure. This pushing of errors into the type system is one
of the key features of Effect. It makes it much harder for us to forget to
handle edge cases, and leads to more robust and reliable products.

<Aside type="note" title="The never type">
In TypeScript, `never` is a special type that represents a value that can never
exist. You may not have had to use it before, but it's a useful tool for
communicating to the type checker that something can't happen.

For example:

```ts twoslash showLineNumbers=false
function getName() {
  return Math.random() > 0.5 ? null : "Alice"
}

function throwAnError() {
  throw new Error("This function always throws an error")
}
```

```ts twoslash showLineNumbers=false
// @errors: 18047
// @noErrors
function getName() {
  return Math.random() > 0.5 ? null : "Alice"
}

function throwAnError() {
  throw new Error("This function always throws an error")
}
//---cut---
const name = getName()
if (name === null) {
  throwAnError()
}
console.log(name.toUpperCase())
// Error ts(18047): 'name' is possibly 'null'.
```

Even though _we_ know that `name` can't be null in the last line of this
example, TypeScript doesn't. We can fix this by using `never`:

```ts twoslash del={1} ins={2} showLineNumbers=false
// @noErrors
function throwAnError() {
function throwAnError(): never {
  throw new Error("This function always throws an error")
}
```

Now TypeScript knows that `throwAnError` will never return, it correctly narrows
the type of `name` to `string` in the last line.

```ts twoslash showLineNumbers=false
function getName(): string | null {
  if (Math.random() > 0.5) {
    return null
  } else {
    return "Alice"
  }
}
function throwAnError(): never {
  throw new Error("This function always throws an error")
}
//---cut---
const name = getName()
if (name === null) {
  throwAnError()
}
console.log(name.toUpperCase())
```
</Aside>

## Fixing our nested Effects with `flatMap`

We can solve all of our problems with a call to `Effect.flatMap`:

```ts twoslash showLineNumbers=false
import { HttpServerResponse } from "@effect/platform"
import { Effect, Layer } from "effect"
import { createServer } from "node:http"
import { Client } from "pg"
const db = new Client({ user: "postgres" })
//---cut---
const users = Effect.promise(async () => {
  const { rows } = await db.query("SELECT * FROM users")
  return { users: rows }
}).pipe(
  Effect.flatMap((body) => HttpServerResponse.json(body))
)
```

The `Effect.flatMap` takes in the body object we want to serialise, passes it to
`HttpServerResponse.json`, and rather than returning a wrapped `Effect` it will
_replace_ the original `Effect` with the new one from `HttpServerResponse.json`.
The result is that our handler has the correct return type and we no longer
have any type errors.

## An aside on pipes

If you're new to functional programming, you might be finding `pipe` difficult
to understand. That's perfectly normal! You can skip this section if you feel
comfortable with `pipe`, but if you don't I'm going to show you some more
examples to help you understand it.

You can visualise a `pipe` as a series of functions that will be called in order
on a value. The value gets "fed" through the pipe.

```ts twoslash showLineNumbers=false
import { pipe } from "effect"

const add = (x: number) => (y: number) => y + x
const mul = (x: number) => (y: number) => y * x
const sub = (x: number) => (y: number) => y - x

const result = pipe(
  1,
  add(2),
  mul(3),
  sub(1)
)
console.log(result)
//=> 8
```

`add`, `mul`, and `sub` are all functions that return functions. So `add(2)`
returns a function that can add 2 to a given number: `add(2)(1)` returns 3.
Our pipeline starts with 1, then passes it through `add(2)`, `mul(3)`, and
`sub(1)`, resulting in 8.

One of the powers this gives you is the ability to add things easily into
the pipeline.

```ts twoslash ins={6-9,14,16,18} showLineNumbers=false
import { pipe } from "effect"

const add = (x: number) => (y: number) => y + x
const mul = (x: number) => (y: number) => y * x
const sub = (x: number) => (y: number) => y - x
const log = (s: string) => (y: number) => {
  console.log(s, y)
  return y
}

const result = pipe(
  1,
  add(2),
  log("1 + 2 ="),
  mul(3),
  log("  * 3 ="),
  sub(1),
  log("  - 1 ="),
)
```

This prints the following, with `result` still being 8:

```
1 + 2 = 3
  * 3 = 9
  - 1 = 8
```

As we migrate more complex endpoints, we'll see how this ability to "tap into"
the pipeline is really useful.

## The end result

Here's our full code so far, with new lines highlighted:

```ts twoslash title=index.ts ins={6,8,12-17,25,29} showLineNumbers=false
import express from "express"

import { NodeHttpServer, NodeRuntime } from "@effect/platform-node"
import { HttpRouter, HttpServerResponse } from "@effect/platform"
import { Effect } from "effect"
import { Client } from "pg"

const db = new Client({ user: "postgres" })

const app = express()

const users = Effect.promise(async () => {
  const { rows } = await db.query("SELECT * FROM users")
  return { users: rows }
}).pipe(
  Effect.flatMap((body) => HttpServerResponse.json(body))
)

const health = Effect.sync(() => {
  return HttpServerResponse.text("ok")
})

const router = HttpRouter.empty.pipe(
  HttpRouter.get("/health", health),
  HttpRouter.get("/users", users),
)

const main = Effect.gen(function* () {
  yield* Effect.promise(() => db.connect())
  app.use(yield* NodeHttpServer.makeHandler(router))
  app.listen(3000, () => {
    console.log("Server is running on http://localhost:3000")
  })
  yield* Effect.never
})

NodeRuntime.runMain(main)
```