---
pagefind: false
title: "TS+ Post-Mortem"
excerpt: "A retrospective look at our attempt to create a TypeScript fork optimized for Effect developer experience, examining what we learned and why we ultimately moved in a different direction"
date: 2025-07-03
authors:
  - michael_arnaldi
tags:
  - Miscellaneous
  - TypeScript
---

In our continuous quest to provide the best possible developer experience for Effect users, we embarked on an ambitious experiment: creating TS+, a TypeScript compiler fork designed to unlock new possibilities for functional programming and maximize developer productivity. Today, we're sharing the story of this experiment—what we hoped to achieve, what we discovered, and why we ultimately chose a different path.

## What Was TS+?

TS+ (TypeScript Plus) was our experimental fork of the TypeScript compiler, designed to enhance developer experience through innovative language tooling. Rather than addressing perceived limitations, we focused on exploring what would be possible if we could extend TypeScript's capabilities with features specifically tailored for modern functional programming patterns.

Our vision centered on six key design goals that would revolutionize how developers interact with type-safe code:

1. **Syntax Compatibility**: Maintain full compatibility with TypeScript's grammar to ensure seamless integration with existing tools like ESLint, Prettier, and IDE extensions
2. **Type-Driven Code Generation**: Enable automatic derivation of runtime code from type definitions—imagine defining a data structure and automatically generating codecs, serializers, and validators
3. **Enhanced Do Syntax**: Create intuitive syntax for effect-based programming, inspired by monadic do notation, making asynchronous and effect code more readable
4. **Fluent API Extensions**: Allow extending types with methods using JSDoc annotations while maintaining tree-shakability, enabling truly ergonomic fluent APIs
5. **Operator Overloading**: Enable custom operators for domain-specific libraries, making mathematical and functional code more expressive
6. **Functional Pipe Operator**: Implement a native pipe operator for cleaner data transformation pipelines

The project was born from our belief that language tooling could be pushed further to create magical developer experiences—where types don't just prevent errors, but actively generate useful code, and where APIs feel natural and discoverable.

## What Was Achieved

Despite being an experimental fork, TS+ successfully demonstrated several groundbreaking capabilities that pushed the boundaries of what's possible with TypeScript:

**Fluent, Tree-Shakable APIs**: We proved that extending types with methods while maintaining optimal bundle sizes was not only possible but practical:

```typescript
// Traditional approach
pipe(
  IO.succeed(0),
  IO.map(n => n + 1),
  IO.flatMap(r => IO.succeedWith(() => console.log(`result: ${r}`)))
)

// TS+ fluent API
const program = IO.succeed(0)
  .map(n => n + 1)
  .flatMap(r => 
    IO.succeedWith(() => {
      console.log(`result: ${r}`);
    })
  );

program.run();
```

**Runtime Type Derivation**: Successfully implemented automatic generation of runtime code from type definitions:

```typescript
// Define once, derive everything
interface Person {
  name: string;
  age: Option<number>;
  friends: Chunk<Person>;
}

// Automatically generated codecs, decoders, guards
export const PersonEncoder: Encoder<Person> = Derive();
export const PersonDecoder: Decoder<Person> = Derive();
export const PersonGuard: Guard<Person> = Derive();

// Usage in practice
const encoded = PersonEncoder.encodeJSON({
  name: "Mike",
  age: Option.some(30),
  friends: Chunk()
});
```

**Extensible Method Definitions**: Created a system where developers could add methods to existing types without modifying original classes:

```typescript
/**
 * @tsplus type IO
 */
export class IO<A> {
  constructor(readonly io: () => A) {}
}

/**
 * @tsplus fluent IO map
 */
export function map<A, B>(self: IO<A>, f: (a: A) => B): IO<B> {
  return new IO(() => f(self.io()));
}

/**
 * @tsplus fluent IO flatMap
 */
export function flatMap<A, B>(self: IO<A>, f: (a: A) => IO<B>): IO<B> {
  return new IO(() => f(self.io()).io());
}

// Usage becomes natural - methods appear on the type:
const result = IO.succeed(10)
  .map(x => x * 2)
  .flatMap(x => IO.succeed(x + 5));
```

**Custom Operator Support**: Demonstrated that TypeScript could support domain-specific operators:

```typescript
/**
 * @tsplus fluent IO zip
 * @tsplus operator IO +
 */
export function zip<A, B>(self: IO<A>, b: IO<B>): IO<[A, B]> {
  return IO(() => [self.io(), b.io()]);
}

// Usage: combining IOs with natural operator syntax
const zipped = IO.succeed(0) + IO.succeed(1);
// Result: IO<[number, number]>
```

**Enhanced Do Syntax**: Made effect-based programming more intuitive by introducing a clean, imperative-style syntax for monadic computations:

```typescript
// Traditional Effect code
Effect.gen(function* (_) {
  const user = yield* _(getUser(id))
  const profile = yield* _(getProfile(user.id))
  const settings = yield* _(getSettings(user.id))
  return { user, profile, settings }
})

// TS+ do syntax - same logic, cleaner syntax
const effectExample = Do(($) => {
  const user = $(getUser(id));
  const profile = $(getProfile(user.id));
  const settings = $(getSettings(user.id));
  return { user, profile, settings };
});
```

**Global Import System**: Streamlined imports while maintaining tree-shaking:

```typescript
// Traditional approach: explicit imports in every file
import { Chunk } from "@tsplus/stdlib/collections/Chunk/definition";
import { Option } from "@tsplus/stdlib/data/Option/definition";
import { IO } from "./IO";

const processData = (items: Chunk<string>) => {
  return items.map(item => Option.some(item));
};

// TS+ global imports: define once in prelude.d.ts
/**
 * @tsplus global
 */
import { Chunk } from "@tsplus/stdlib/collections/Chunk/definition";

/**
 * @tsplus global
 */
import { Option } from "@tsplus/stdlib/data/Option/definition";

// Usage: no imports needed, types available globally
const processData = (items: Chunk<string>) => {
  return items.map(item => Option.some(item));
};

// TS+ automatically adds imports only where types are used
// Tree-shaking still works - unused globals aren't bundled
```

**Native Pipe Operator**: Implemented a built-in pipe operator for cleaner data transformation pipelines:

```typescript
// Traditional pipe function approach
const result = pipe(
  Either.right({ xxx: 0 }),
  Either.map(n => n.xxx),
  Either.map(n => n + 1),
  Either.map(n => `hello: ${n}`),
  Either.map(s => s.length)
);

// TS+ native pipe operator using /
const result = Either.right({ xxx: 0 }) 
  / Either.map((n) => n.xxx) 
  / Either.map((n) => n + 1) 
  / Either.map((n) => `hello: ${n}`) 
  / Either.map((s) => s.length);
```

## How Far We Went

We didn't approach TS+ as a casual experiment—we went all-in. For roughly a year, we committed significant resources and energy to prove that this approach could work at scale.

**Deep Technical Investment**: We spent countless hours in the depths of the TypeScript compiler codebase, understanding its intricate parsing, type-checking, and compilation phases. This wasn't surface-level modification; we were fundamentally extending the language's capabilities while maintaining backward compatibility.

**Complete Ecosystem Rewrite**: Perhaps most significantly, we rewrote the entire Effect ecosystem using TS+. This meant porting thousands of lines of carefully crafted functional programming abstractions, rebuilding our core libraries, and ensuring that all the complex type-level computations still worked correctly with our enhanced compiler.

**Production Adoption**: The experiment reached a point where we had production users depending on alpha releases. Real projects, real applications, real teams betting their development workflow on our experimental fork. This level of adoption validated that TS+ wasn't just a theoretical exercise—it was solving genuine developer pain points.

The scale of our commitment demonstrated our conviction that language tooling could be dramatically improved. We weren't just building a proof-of-concept; we were building a complete alternative development experience.

## What Went Wrong

Despite our achievements, several critical issues emerged that ultimately led us to reconsider the viability of TS+ as a long-term solution.

**Fundamental Architecture Mismatch**: The issue was more fundamental than simple tooling compatibility. Most modern tooling achieves speed through parallel compilation of each file, something that doesn't really work with `tsc`'s architecture. Our fork inherited this limitation, making it incompatible with the performance expectations of modern development workflows.

**Tooling Ecosystem Fragmentation**: The compilation required using a different version of `tsc`, which meant TS+ didn't work out of the box with essential development tools like Next.js, Vite, and other modern build systems. Each tool expected the standard TypeScript compiler, and our fork created immediate compatibility issues.

**Plugin Maintenance Burden**: We built plugins to patch various integrations, but this created a maintenance nightmare. Every update to popular build tools required us to update our patches, creating a constant game of catch-up. We were essentially maintaining parallel versions of the entire TypeScript tooling ecosystem.

**Performance Penalties**: The performance penalty was substantial, especially in environments like Hot Module Replacement (HMR). Development workflows that were previously snappy became sluggish, directly impacting developer productivity—the very thing we were trying to improve.

**Architectural Constraints**: The performance price of some features required careful repository design with isolated modules that could be compiled independently. Teams had to structure their codebases around our compiler's limitations, creating domains packages with all codecs and types separated from business logic. This architectural complexity was a significant burden on adopters.

**Limited Value Proposition**: Perhaps most critically, the tradeoff wasn't compelling enough. While we had new shiny features, there wasn't anything there that couldn't be accomplished natively in TypeScript with a comparable amount of syntax. Our enhancements looked cleaner to the untrained eye, but the syntactic improvements were largely cosmetic—there wasn't enough fundamental value to justify using a different language.

The harsh reality was that the friction of maintaining a language fork outweighed the benefits of the features we'd built.

## What We Learned

The TS+ experiment taught us invaluable lessons about the boundaries of language tooling and developer experience enhancement. These learnings now guide our approach to improving the Effect ecosystem.

**Runtime Behavior Must Remain Unchanged**: We learned that we should never change the runtime behavior of code. The moment we alter how JavaScript executes, we create an entirely different language with all the associated compatibility and maintenance burdens. TypeScript's value lies in being a compilation target to standard JavaScript.

**Targeted Compiler Patches for Better Diagnostics**: Instead of wholesale language changes, we can strategically patch the compiler to produce better, Effect-specific diagnostics that improve the IDE experience when editing `.ts` files that use Effect. Crucially, we ensure these same diagnostics are available in CI during type-checking, maintaining consistency between development and production environments.

**LSP and IDE Plugins for Developer Experience**: We can use Language Server Protocol (LSP) and IDE plugins to dramatically improve the developer experience around Effect's verbosity without changing the language itself. Our dedicated [Effect Language Service Plugin](https://github.com/Effect-TS/language-service) exemplifies this approach.

**Never Cross the Build-Tooling Boundary**: Perhaps the most important lesson: we should never cross the boundary of having to integrate with build tooling. The moment we require custom build plugins or non-standard compilation processes, we create friction that compounds over time. The TypeScript ecosystem's strength lies in its tooling compatibility, and we must respect that boundary.

This approach has proven far more sustainable—we enhance the development experience through intelligent tooling while maintaining full compatibility with the existing TypeScript ecosystem.

## Are We Really Over It?

Not entirely. While our experience with TS+ taught us valuable lessons about the boundaries of language modification, recent developments have changed some of the fundamental constraints that made our fork impractical.

**Performance Constraints Are Lifting**: With the advent of TSGo, the official Go port of the TypeScript compiler, many of the performance constraints that plagued our original fork are no longer in place. The architectural limitations that prevented parallel compilation are being addressed at the compiler level.

**Tooling Remains the Real Burden**: However, the tooling ecosystem remains a significant burden, and we're pretty sure that changing the semantics of a `.ts` file remains a terrible idea. The compatibility issues we encountered weren't just performance-related—they were fundamental to how the TypeScript ecosystem expects files to behave.

**Different File Extension, Major Advantages Required**: If we were to do anything at the language level again, we would need to work with a different file extension and we would need to gain some major advantages that justify the ecosystem split. The bar for creating a new language variant is incredibly high.

**The JSX Opportunity**: One realm where we think there is potential room for a (maybe temporary) fork could be JSX. Currently, we say that Effect is primarily a backend framework—not really because it can't theoretically be useful in frontend, but rather because of an impedance mismatch from how React-like frameworks behave. These frameworks don't have type inference of errors and dependencies, and they take over the application lifecycle. We have solutions to work in those environments, but they really shine only in specific contexts with substantial business logic in the frontend.

The reality is that there's no technical reason Effect wouldn't shine in frontend development, except that we commonly agree on how JSX should be typed and what kind of primitives back it up. JSX could be more flexible and enable development of an Effect-native UI framework that builds on top of Effect's capabilities and provides amazing developer experience end-to-end. Such a framework could leverage Effect's error handling, dependency injection, and effect management directly in the component model, creating a truly integrated development experience that current React-like frameworks can't match.

## AI Development with Effect

The developer tooling space has gained an unexpected ally that fundamentally changes how we think about syntax complexity and learning curves: advanced AI models that excel at understanding and generating Effect code.

**AI Models Excel at Effect Patterns**: New models like Claude Code 4 Sonnet are exceptionally good at understanding Effect patterns and producing production-grade quality code. What for humans might appear as verbosity becomes precise description of high-level semantics that models can interpret really well. The explicit nature of Effect's type system and functional patterns provides rich context that AI can leverage effectively.

**Smoothing the Learning Curve**: The learning curve of new syntax or less-known standard syntax is smoothed out by prompting models to use tools like the [Effect MCP server](https://github.com/tim-smart/effect-mcp). This allows developers to work with Effect through natural language descriptions while the AI handles the specific syntax and patterns.

**Implications for Language Tooling**: All this added AI tooling can also play a role in potentially adopting new language tooling. The learning curve for an extension of TypeScript that supports JSX-enhanced capabilities isn't a far-fetched target for an AI to pick up instantly. Where human developers might struggle with new syntax or unfamiliar patterns, AI assistants can bridge that gap seamlessly.

This AI capability fundamentally changes the cost-benefit analysis of custom language features. The traditional barrier of developer adoption and learning curves becomes much lower when AI can act as an intelligent interface between human intent and specialized syntax.

